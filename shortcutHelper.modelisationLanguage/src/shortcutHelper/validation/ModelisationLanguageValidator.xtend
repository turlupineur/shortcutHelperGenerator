/*
 * generated by Xtext 2.15.0
 */
package shortcutHelper.validation

import java.util.ArrayList
import java.util.Collection
import java.util.HashMap
import java.util.List
import java.util.Set
import org.eclipse.emf.common.util.EList
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EStructuralFeature
import org.eclipse.xtext.validation.Check
import shortcutHelper.modelisationLanguage.AttribuableValue
import shortcutHelper.modelisationLanguage.BackendParameter
import shortcutHelper.modelisationLanguage.BackendParameterDeclaration
import shortcutHelper.modelisationLanguage.CallComponentMethod
import shortcutHelper.modelisationLanguage.CallLogic
import shortcutHelper.modelisationLanguage.Command
import shortcutHelper.modelisationLanguage.CommandParameter
import shortcutHelper.modelisationLanguage.CommandParameterReference
import shortcutHelper.modelisationLanguage.ComponentBackendParameterValueAttribut
import shortcutHelper.modelisationLanguage.ConditionImplementation
import shortcutHelper.modelisationLanguage.Functionality
import shortcutHelper.modelisationLanguage.Helper
import shortcutHelper.modelisationLanguage.Implementation
import shortcutHelper.modelisationLanguage.ImplementationLine
import shortcutHelper.modelisationLanguage.Method
import shortcutHelper.modelisationLanguage.MethodArgument
import shortcutHelper.modelisationLanguage.MethodArgumentValueAttribut
import shortcutHelper.modelisationLanguage.ModelisationLanguagePackage
import shortcutHelper.modelisationLanguage.PARAMETER_CATEGORY
import shortcutHelper.modelisationLanguage.Service
import shortcutHelper.modelisationLanguage.Shortcut
import shortcutHelper.modelisationLanguage.UsableSystemComponent
import shortcutHelper.modelisationLanguage.UsingSystemKomponent
import shortcutHelper.modelisationLanguage.Util
import shortcutHelper.modelisationLanguage.Variable

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class ModelisationLanguageValidator extends AbstractModelisationLanguageValidator {
	@Check
	def checkUtil(Util util){
		checkNameComponent(util,util.getName());
	}
	
	
	@Check
	def checkHelper(Helper helper){
		checkNameComponent(helper,helper.getName());
	}
	
	@Check
	def checkService(Service service){
		checkNameComponent(service,service.getName());
	}
	@Check
	def checkMethod(Method method){
		checkArgumentDeclarationForMethod(method);
	}
	
	@Check
	def checkParameterDeclarationForParameterDeclaration(BackendParameterDeclaration parameterDeclaration) {
		if(parameterDeclaration.noParameter != null && parameterDeclaration.parameters.size != 0
		){
			error("No parameters can be declared after specifying 'NoParameter'.",ModelisationLanguagePackage.Literals.METHOD__NO_ARGUMENT, parameterDeclaration.noParameter);
		}
		if(parameterDeclaration.parameters.size!= 0){
			val Set<String> setNames = CollectionLiterals.newHashSet;			
			for (argument : parameterDeclaration.parameters) {
				if(!setNames.contains(argument.getName())){
					setNames.add(argument.getName());
				}else{
					error("Another parameter has the same name.",ModelisationLanguagePackage.Literals.BACKEND_PARAMETER_DECLARATION__PARAMETERS,setNames.size);
				}
			}
		}
	}
	
	@Check
	def checkCommandParameterTowarsBackendCommand(Command command){
		val Functionality functionality = command.functionality;
		val List<CommandParameter> parameters = command.parameters;
		if(functionality != null && functionality.parameterDeclaration.parameters != null && functionality.parameterDeclaration.parameters.size != 0){
			
			val HashMap<String,BackendParameter> mapBackendParameters = CollectionLiterals.newHashMap;
			
			for(backendParameter: functionality.parameterDeclaration.parameters){
				mapBackendParameters.put(backendParameter.name,backendParameter);
			}
			
			var cpt = 0;
			for(commandParameter : parameters){
				val nameReferenceParameter = commandParameter.backendParameterReference.backendCommandParameter.name;
				val BackendParameter relatedBackendParameter = mapBackendParameters.get(nameReferenceParameter);
				if(relatedBackendParameter != null){
					if(relatedBackendParameter.type != commandParameter.type){
						error("Parameter's type not correct.Should be from type '" + relatedBackendParameter.type.name + "'.",ModelisationLanguagePackage.Literals.COMMAND__PARAMETERS,cpt);
					}else if(relatedBackendParameter.parameterCategory != commandParameter.parameterCategory){
						error("Parameter's category not correct.Should be '" + relatedBackendParameter.parameterCategory.getName + "'.",ModelisationLanguagePackage.Literals.COMMAND__PARAMETERS,cpt);
					}
					mapBackendParameters.remove(nameReferenceParameter);
				}
				cpt++;
			}
			if(mapBackendParameters.size != 0){
				error("Parameter '" + mapBackendParameters.values.get(0).name
				+ "' is missing.",ModelisationLanguagePackage.Literals.COMMAND__PARAMETERS);
			}
		}
	}
	
	@Check
	def checkParameterDeclaration(BackendParameterDeclaration parameterDeclaration)
	{
		checkParameterDeclarationForParameterDeclaration(parameterDeclaration); 
		var cpt = 0;
		for(parameter : parameterDeclaration.parameters){
			checkParameter(parameter,cpt);
			cpt++;
		}
	}
	@Check
	def checkShortcut_allRequiredParametersDeclared(Shortcut shortcut)
	{
		val Set<String> setNames = CollectionLiterals.newHashSet	
		for(CommandParameterReference param:shortcut.paramReferences){
			setNames.add(param.param.name);
		}
		val Command command = shortcut.command;
		for(parameterCommand: command.parameters){
			if(!setNames.contains(parameterCommand.name) && parameterCommand.parameterCategory == PARAMETER_CATEGORY.REQUIRED){
				error("Shortcut must specify value for parameter '" + parameterCommand.name + "'",ModelisationLanguagePackage.Literals.SHORTCUT__PARAM_REFERENCES);
			}
		}
	}
	
	@Check
	def checkShortcut_parameterNotSpecifiedMoreThanOnce(Shortcut shortcut){
		val Set<String> setNames = CollectionLiterals.newHashSet;
		var int cpt = 0;
		for(CommandParameterReference commandParameterReference: shortcut.paramReferences){
			if(setNames.contains(commandParameterReference.param.name)){
				error("Variable '" + commandParameterReference.param.name + "' has already been set.",ModelisationLanguagePackage.Literals.SHORTCUT__PARAM_REFERENCES,cpt);					
			}else{
				setNames.add(commandParameterReference.param.name);
			}
			cpt++;
		}
	}
	
	@Check
	def checkUsingSystemComponent(UsingSystemKomponent usingSystemKomponent){
		if(usingSystemKomponent.nothing != null && usingSystemKomponent.components != null){
			error("No component can be declared after specifying 'nothing'.",ModelisationLanguagePackage.Literals.USING_SYSTEM_KOMPONENT__COMPONENTS);
		}
		checkUsingSameComponent(usingSystemKomponent.components, ModelisationLanguagePackage.Literals.USING_SYSTEM_KOMPONENT__COMPONENTS);
		checkSelfReference(usingSystemKomponent.eContainer, usingSystemKomponent.components,ModelisationLanguagePackage.Literals.USING_SYSTEM_KOMPONENT__COMPONENTS);
	}
	
	def checkSelfReference(EObject parent, EList<UsableSystemComponent> list, EStructuralFeature feature) {
		var UsableSystemComponent parentComponent;
		if(parent instanceof UsableSystemComponent){
			parentComponent = parent;
		}else{
			return
		}
		if(list!= null)
		{
			var cpt = 0;
			for (usableSystemComponent: list) {
				if( usableSystemComponent == parentComponent){
					error("Component cannot reference itself.",feature,cpt);
				}	
				cpt++;
			}
		}
	}
	// Check used component is declared in 'using'
	@Check
	def checkRefComponent(AttribuableValue attribuableValue){
//		if(attribuableValue.method !== null){
//			val EObject rootImplementation = ImplementationUtil.getRootParentImplementation(attribuableValue.eContainer().eContainer());
//			
//			var UsableSystemComponent systemComponent = attribuableValue.method.eContainer as UsableSystemComponent;
//			
////			if(systemComponent == null && attribuableValue.logic != null){
////				systemComponent = attribuableValue.logic;
////			}
//			
//			val UsingSystemKomponent usingSystemKomponent = ImplementationUtil.extractUsingKomponentsFromObject(rootImplementation);
//			
//			if(!usingSystemKomponent.components.contains(systemComponent)){
//				error("Component was not declared. Please declare used components in 'using'.",ModelisationLanguagePackage.Literals.CALL_COMPONENT_METHOD__METHOD);
//			}
//			
//		}
	}
	// Check used service is declared in 'using'
	@Check
	def checkRefComponent(ImplementationLine implementationLine){
//		if(implementationLine.calledMethod!== null){
//			val EObject rootImplementation = ImplementationUtil.getRootParentImplementation(implementationLine.eContainer());
//			
//			var UsableSystemComponent systemComponent = implementationLine.calledMethod.eContainer as UsableSystemComponent;
//			
//			val UsingSystemKomponent usingSystemKomponent = ImplementationUtil.extractUsingKomponentsFromObject(rootImplementation);
//			
//			if(!usingSystemKomponent.components.contains(systemComponent)){
//				error("Component was not declared. Please declare used components in 'using'.",ModelisationLanguagePackage.Literals.IMPLEMENTATION_LINE__CALLED_METHOD);
//			}
//		}
	}
	/**
	 * Ensure types are respected.
	 */
	@Check
	def checkObjectReturn(AttribuableValue attribuableValue){
//		if(attribuableValue.method!== null){
//			var TypeData typeReturn ;
//			if(attribuableValue.method.returnType === null){
//				typeReturn  = null;
//			}else{
//				typeReturn = attribuableValue.method.returnType.type;
//			}
////			if(attribuableValue.logic != null){
////				typeReturn = attribuableValue.logic.returningDeclaration.returnType.type
////			}
//			
//
//			var Variable variableForAttribution = null;
//			if(attribuableValue.eContainer.eContainer instanceof Predicat){
//				val Predicat predicat = attribuableValue.eContainer.eContainer as Predicat;
//				variableForAttribution = predicat.variable
//			}else if(attribuableValue.eContainer.eContainer  instanceof VariableValueAttribution){
//				val VariableValueAttribution variableValueAttribution = attribuableValue.eContainer.eContainer as VariableValueAttribution
//				variableForAttribution = variableValueAttribution.variable;
//			}
//			
//			var TypeData typeVariable = null;
//			if(variableForAttribution != null){
//				typeVariable = variableForAttribution.typeVariable;
//			}
//			if(typeVariable != null && typeReturn == null){
//				error("Method doesn't return anything.",ModelisationLanguagePackage.Literals.CALL_COMPONENT_METHOD__METHOD);								
//			}else if((typeVariable != null && typeReturn != null &&!typeVariable.name.equals(typeReturn.name))){
//				error("Type not compatible.",ModelisationLanguagePackage.Literals.CALL_COMPONENT_METHOD__METHOD);				
//			}else{
//				System.out.println();
//			}
//		}
	}
	
	@Check
	def checkCallComponentMethod_allParametersHaveBeenSet(CallComponentMethod callComponentMethod){
		val Method method = callComponentMethod.method
		val EList<MethodArgument> requiredArguments = method.arguments
		val Set<String> setNames = CollectionLiterals.newHashSet;
		if(callComponentMethod.argumentAttributions != null){
			for(MethodArgumentValueAttribut methodArgumentValueAttribut: callComponentMethod.argumentAttributions){
				setNames.add(methodArgumentValueAttribut.argument.name);
			}
			for(MethodArgument methodArgument: requiredArguments){
				if(!setNames.contains(methodArgument.name)){
					error("Variable '" + methodArgument.name + "' has not been set.",ModelisationLanguagePackage.Literals.CALL_COMPONENT_METHOD__METHOD);
				}
			}
		}
	}
	@Check
	def checkCallLogic_allParametersHaveBeenSet(CallLogic callLogic){
		val EList<BackendParameter> parameters = callLogic.logic.parameterDeclaration.parameters;
		val Set<String> setNames = CollectionLiterals.newHashSet;
		if(callLogic.componentBackendParameterAttributions != null){
			for(ComponentBackendParameterValueAttribut componentBackendParameterValueAttribut: callLogic.componentBackendParameterAttributions){
					setNames.add(componentBackendParameterValueAttribut.parameter.name);				
			}
			for(BackendParameter backendParameter: parameters){
				if(!setNames.contains(backendParameter.name) && backendParameter.parameterCategory  == PARAMETER_CATEGORY.REQUIRED){
					error("Parameter '" + backendParameter.name + "' has not been set.",ModelisationLanguagePackage.Literals.CALL_LOGIC__LOGIC);
				}
			}
		}
	}
	
	@Check
	def checkCallLogic_parameterNotSpecifiedMoreThanOnce(CallLogic callLogic){
		val Set<String> setNames = CollectionLiterals.newHashSet;
		if(callLogic.componentBackendParameterAttributions != null){
			var int cpt = 0;
			for(ComponentBackendParameterValueAttribut componentBackendParameterValueAttribution: callLogic.componentBackendParameterAttributions){
				if(setNames.contains(componentBackendParameterValueAttribution.parameter.name)){
					error("Variable '" + componentBackendParameterValueAttribution.parameter.name + "' has already been set.",ModelisationLanguagePackage.Literals.CALL_LOGIC__COMPONENT_BACKEND_PARAMETER_ATTRIBUTIONS,cpt);					
				}else{
					setNames.add(componentBackendParameterValueAttribution.parameter.name);
				}
				cpt++;
			}
		}
	}
	@Check
	def checkCallComponentMethod_parameterNotSpecifiedMoreThanOnce(CallComponentMethod callComponentMethod){
		val Set<String> setNames = CollectionLiterals.newHashSet;
		if(callComponentMethod.argumentAttributions != null){
			var int cpt = 0;
			for(MethodArgumentValueAttribut methodArgumentValueAttribut: callComponentMethod.argumentAttributions){
				if(setNames.contains(methodArgumentValueAttribut.argument.name)){
					error("Variable '" + methodArgumentValueAttribut.argument.name + "' has already been set.",ModelisationLanguagePackage.Literals.CALL_COMPONENT_METHOD__ARGUMENT_ATTRIBUTIONS,cpt);					
				}else{
					setNames.add(methodArgumentValueAttribut.argument.name);
				}
				cpt++;
			}
		}
	}
	
	@Check
	def checkImplementation(Implementation implementation){
		val Set<String> setNames = CollectionLiterals.newHashSet;
		for(implLine : implementation.implementationLines)
		{
			if(implLine instanceof Variable){
				val Variable variable = implLine;
				if(setNames.contains(variable.name)){
//					IMPLEMENTATION__IMPLEMENTATION_LINES
//					error("Another variable has the same name.",ModelisationLanguagePackage.Literals.IMPLEMENTATION_,setNames.size);
				}else{
					setNames.add(variable.name);
				}
			}
		}
	}
	@Check
	def checkConditionImplementation(ConditionImplementation conditionImplementation){
		val Collection<Variable> parentVariables = getVariablesFromParent(conditionImplementation);
		val Collection<ImplementationLine> variablesInCondition = conditionImplementation.implementationLines.filter[it instanceof Variable].toList
		val Collection<Variable> localVariables = toCollectionVariable(variablesInCondition); 
		
		
		
		val Set<String> setNames = CollectionLiterals.newHashSet;			
		
		for(parentVariable: parentVariables){
			if(!setNames.contains(parentVariable.getName())){
				setNames.add(parentVariable.getName());
			}
		}
		
		var int cpt = 0;
		for (localVariable: localVariables) {
			if(!setNames.contains(localVariable.getName())){
				setNames.add(localVariable.getName());
			}else{
//				error("Another variable has the same name.",ModelisationLanguagePackage.Literals.CONDITION__IMPLEMENTATION_LINES,cpt);
			}
			cpt++;
		}
	}
	
	def Collection<Variable> getVariablesFromParent(EObject child){
		val EObject pEObject = child.eContainer;
		
		if(pEObject instanceof Implementation){
			val Implementation parent = pEObject
			val List<ImplementationLine> variablesParent = parent.implementationLines.filter[it instanceof Variable].toList;
			return toCollectionVariable(variablesParent);	
		}else if (pEObject instanceof ImplementationLine){
			val Collection<Variable> parentVariables = getVariablesFromParent(pEObject);
			if(pEObject instanceof ConditionImplementation){
				val ConditionImplementation parent = pEObject;
				val List<ImplementationLine> variablesLocal = parent.implementationLines.filter[it instanceof Variable].toList;
					
				parentVariables.addAll(toCollectionVariable(variablesLocal));
			}
			return parentVariables;
		}
		return new ArrayList();
	}
	
	def Collection<Variable> toCollectionVariable(Collection<ImplementationLine> variables){
		val Collection<Variable> allVariables = new ArrayList<Variable>();
		for(variable: variables){
			allVariables.add(variable as Variable);
		}
		return allVariables;
	}
	
	def checkUsingSameComponent(EList<UsableSystemComponent> list,EStructuralFeature feature) {
		
		if(list != null){
			val Set<String> setNames = CollectionLiterals.newHashSet;			
			for (usableSystemComponent: list) {
				if(!setNames.contains(usableSystemComponent.getName())){
					setNames.add(usableSystemComponent.getName());
				}else{
					error("This component has already been declared.",feature,setNames.size);
				}
			}
		}
	}
	
	def checkNameComponent(EObject o, String nameComponent) {
		val interfaceName = o.class.simpleName.replace("Impl","");
		if(!nameComponent.endsWith(interfaceName)){
			error("Component's name should ends with '" + interfaceName + "'",o, null);
		}
	}
	
	def private checkArgumentDeclarationForMethod(Method method) {
		if(method.noArgument!= null && method.arguments.size != 0){
			error("No arguments can be declared after specifying 'NoArgument'.",ModelisationLanguagePackage.Literals.METHOD__NO_ARGUMENT, method.noArgument);
		}
		if(method.arguments.size!= 0){
			val Set<String> setNames = CollectionLiterals.newHashSet;			
			for (argument : method.arguments) {
				if(!setNames.contains(argument.getName())){
					setNames.add(argument.getName());
				}else{
					error("Another argument has the same name.",ModelisationLanguagePackage.Literals.METHOD__ARGUMENTS,setNames.size);
				}
			}
		}
	}
	
	def checkParameter(BackendParameter parameter, int paramNumber)
	{
//		parameter.parameterCategory
		if(PARAMETER_CATEGORY.OPTIONAL == parameter.parameterCategory){
			if(!parameter.name.startsWith("o")){
				error("An optional parameter's name must start with 'o'.", ModelisationLanguagePackage.Literals.BACKEND_PARAMETER_DECLARATION__PARAMETERS, paramNumber);
			}	
		}
		if(PARAMETER_CATEGORY.DEFAULT== parameter.parameterCategory){
			if(!parameter.name.startsWith("d")){
				error("An optional parameter's name must start with 'd'.", ModelisationLanguagePackage.Literals.BACKEND_PARAMETER_DECLARATION__PARAMETERS, paramNumber);
			}	
		}
	}
	
}
